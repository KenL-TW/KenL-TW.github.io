<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI æµç¨‹è¦–è¦ºåŒ–ï¼šé›»å­å•†å‹™é¡§å®¢åˆ†æ</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    /* å…¨åŸŸæ¨£å¼ */
    html, body {
      font-family: 'Inter', sans-serif;
      scroll-behavior: smooth;
      overflow-x: hidden;
      background-color: #0d1117;
      background-image: radial-gradient(at 100% 0%, #1f2937 0%, #0d1117 70%);
      transition: background-image 1s ease-in-out;
    }
    
    #ai-app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }

    .phases-wrapper {
      display: grid;
      grid-template-columns: repeat(3, minmax(300px, 1fr));
      gap: 2rem;
      width: 100%;
      max-width: 1400px;
      margin-top: 2rem;
    }
    
    @media (max-width: 1024px) {
      .phases-wrapper {
        grid-template-columns: 1fr;
      }
    }
    
    .phase-container {
      width: 100%;
      background-color: #1a202c;
      border: 1px solid #2d3748;
      border-radius: 1.5rem;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      padding: 2rem;
      transition: all 0.5s ease-in-out;
      opacity: 0.5;
      transform: translateY(20px) scale(0.95);
      min-height: 550px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    .phase-container.active {
      opacity: 1;
      transform: translateY(0) scale(1);
      box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
      background-color: #2d3748;
    }

    /* éšæ®µä¸€ - æ„ŸçŸ¥æ¨£å¼ */
    .data-chaos-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    .data-icon {
      position: absolute;
      animation: float 10s ease-in-out infinite;
      transition: all 0.8s ease-in-out;
      opacity: 1;
    }
    @keyframes float {
      0% { transform: translate(0, 0) rotate(0deg); }
      50% { transform: translate(10px, 10px) rotate(10deg); }
      100% { transform: translate(0, 0) rotate(0deg); }
    }
    .data-icon.fade-out {
      opacity: 0;
      transform: scale(0.5);
    }
    
    .pipeline {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
    }
    .pipeline-step {
        width: 90%;
        background: linear-gradient(135deg, #1f2937, #374151);
        border: 2px solid #4b5563;
        border-radius: 1rem;
        padding: 1rem;
        text-align: center;
        margin: 0.5rem 0;
        opacity: 0;
        transform: translateY(10px);
        transition: all 0.5s ease-out;
    }
    .pipeline-step.active {
        opacity: 1;
        transform: translateY(0);
    }
    .pipeline-arrow {
      width: 2px;
      height: 30px;
      background-color: #3b82f6;
      transition: height 0.5s ease-in-out;
      opacity: 0;
    }
    .pipeline-arrow.active { opacity: 1; }

    /* éšæ®µäºŒ - ç†è§£æ¨£å¼ */
    .training-area {
      position: relative;
      height: 300px;
      width: 100%;
      background-color: #1f2937;
      border: 1px solid #4b5563;
      border-radius: 1rem;
      cursor: crosshair;
    }
    .data-point {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      position: absolute;
      transform: translate(-50%, -50%);
      transition: all 0.5s ease-in-out;
    }
    .decision-boundary {
      position: absolute;
      width: 3px;
      height: 120%;
      background-color: #3b82f6;
      box-shadow: 0 0 15px #3b82f6;
      left: 50%;
      top: -10%;
      transform-origin: center center;
      transition: transform 0.2s ease-in-out;
    }
    .decision-boundary-complex {
        background: none;
        box-shadow: none;
        border-right: 3px dashed #3b82f6;
    }

    /* éšæ®µä¸‰ - è¡Œå‹•æ¨£å¼ */
    .new-data-point {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      position: absolute;
      transform: translate(-50%, -50%);
      transition: all 0.5s ease-in-out;
      box-shadow: 0 0 10px #f97316;
      z-index: 10;
    }
    .prediction-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 1rem;
    }
    .final-prediction-result {
      opacity: 0;
      transform: translateY(20px);
      transition: all 1s ease-out;
    }
    .final-prediction-result.active {
      opacity: 1;
      transform: translateY(0);
    }
    
    .summary-section {
        opacity: 0;
        transform: translateY(20px);
        transition: all 1s ease-out;
    }
    .summary-section.active {
        opacity: 1;
        transform: translateY(0);
    }

    .tooltip {
        position: absolute;
        background-color: rgba(30, 41, 59, 0.9);
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        font-size: 0.875rem;
        pointer-events: none;
        z-index: 20;
        transform: translate(-50%, -120%);
        white-space: nowrap;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
    }
    .tooltip.visible {
        opacity: 1;
    }

    @keyframes pulse-green {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
      }
      50% {
        box-shadow: 0 0 0 10px rgba(34, 197, 94, 0);
      }
    }

    .misclassified-point {
        animation: pulse-green 1.5s infinite;
        border: 2px solid #22c55e !important;
    }

    .value-change-animation {
        animation: value-pulse 0.5s ease-out;
    }

    @keyframes value-pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); color: #60a5fa; }
        100% { transform: scale(1); }
    }
    
    /* æ–°å¢çš„çµæŸæ­¥é©Ÿæ¨£å¼ */
    .ending-step-container {
        opacity: 0;
        transform: translateY(20px);
        transition: all 1s ease-out;
    }
    .ending-step-container.active {
        opacity: 1;
        transform: translateY(0);
    }

    /* çµæŸç•«é¢èˆ‡æ•™å­¸å€å¡Š */
    .deep-dive-section {
        opacity: 0;
        transform: translateY(20px);
        transition: all 1s ease-out;
    }
    .deep-dive-section.active {
        opacity: 1;
        transform: translateY(0);
    }
  </style>
</head>
<body class="bg-gray-900 text-white">
  <div id="ai-app">
    <header class="text-center my-8">
      <h1 class="text-5xl font-bold tracking-tight mb-4 text-slate-100">AI æµç¨‹è¦–è¦ºåŒ–ï¼šé›»å­å•†å‹™é¡§å®¢åˆ†æ</h1>
      <a href="../../index.html"
        class="btn btn-primary btn-lg rounded-pill shadow back-fab d-none d-md-inline-flex"
        aria-label="è¿”å›é¦–é ï¼ˆå¿«æ·éµ Hï¼‰"
        aria-keyshortcuts="H">
        <i class="bi bi-house-door me-2"></i> å›é¦–é 
        </a>
      <p class="text-lg text-gray-400 max-w-3xl mx-auto">
        æƒ³åƒæˆ‘å€‘æ˜¯ä¸€å®¶é›»å­å•†å‹™å…¬å¸ï¼Œç›®æ¨™æ˜¯é æ¸¬å“ªäº›æ–°é¡§å®¢æœ€å¯èƒ½è³¼è²·æˆ‘å€‘çš„ç”¢å“ã€‚é€éä»¥ä¸‹ä¸‰å€‹éšæ®µï¼Œæˆ‘å€‘å°‡ AI æ¨¡å‹çš„é‹ä½œéç¨‹å®Œæ•´è¦–è¦ºåŒ–ã€‚
      </p>
      <div class="mt-8 flex justify-center space-x-4">
        <button @click="startAutomation" :disabled="isAutomating || currentPhase > 1" :class="{'opacity-50 cursor-not-allowed': isAutomating || currentPhase > 1}" class="px-8 py-3 bg-blue-600 hover:bg-blue-700 rounded-full font-bold transition-colors shadow-lg hover:shadow-xl">
          <span v-if="isAutomating">è‡ªå‹•åˆ†æä¸­...</span>
          <span v-else>é–‹å§‹è‡ªå‹•åˆ†æ</span>
        </button>
        <button v-if="!isAutomating && currentPhase <= 2" @click="nextPhase" class="px-8 py-3 bg-gray-600 hover:bg-gray-700 rounded-full font-bold transition-colors shadow-lg hover:shadow-xl">
          {{ nextButtonText }}
        </button>
      </div>
    </header>

    <div class="phases-wrapper">
      <!-- éšæ®µä¸€ï¼šæ„ŸçŸ¥ - è³‡æ–™æº–å‚™çš„è—è¡“ -->
      <section class="phase-container" :class="{ 'active': currentPhase === 1 }">
        <div class="text-center mb-4">
          <h2 class="text-3xl font-semibold mb-2">éšæ®µä¸€ï¼šæ„ŸçŸ¥</h2>
          <p class="text-gray-400 text-sm">å°‡é¾é›œçš„é¡§å®¢è³‡æ–™è½‰åŒ–ç‚º AI å¯ç†è§£çš„æ ¼å¼ã€‚</p>
        </div>
        <div class="visualizer">
          <div v-if="phase1Step === 'raw'" class="data-chaos-container">
            <p class="text-sm text-gray-400 mb-2">åŸå§‹è³‡æ–™ï¼šåŒ…å«ç€è¦½ç´€éŒ„ã€è³¼è²·æ­·å²ç­‰æ··äº‚æ•¸æ“š</p>
            <div v-for="n in 50" :key="n" class="data-icon" :style="getIconStyle(n)">
              <img :src="getIcon(n)" class="w-8 h-8" />
            </div>
          </div>
          <div v-if="phase1Step !== 'raw'" class="pipeline">
            <div class="pipeline-step" :class="{ 'active': phase1Step === 'cleaning' }">
              <p class="font-semibold text-lg">1. è³‡æ–™æ¸…æ´—</p>
              <p class="text-xs text-gray-400 mt-1">ç§»é™¤éºå¤±å€¼ã€é‡è¤‡è³‡æ–™ï¼Œè™•ç†ç•°å¸¸å€¼ï¼Œç¢ºä¿è³‡æ–™å“è³ªã€‚</p>
            </div>
            <div class="pipeline-arrow" :class="{ 'active': phase1Step === 'features' }"></div>
            <div class="pipeline-step" :class="{ 'active': phase1Step === 'features' }">
              <p class="font-semibold text-lg">2. ç‰¹å¾µå·¥ç¨‹</p>
              <p class="text-xs text-gray-400 mt-1">å¾è³‡æ–™ä¸­æå–é—œéµç‰¹å¾µï¼Œå¦‚ã€Œæœ€è¿‘ç€è¦½æ¬¡æ•¸ã€æˆ–ã€Œå¹³å‡è³¼ç‰©é‡‘é¡ã€ã€‚</p>
            </div>
            <div class="pipeline-arrow" :class="{ 'active': phase1Step === 'normalization' }"></div>
            <div class="pipeline-step" :class="{ 'active': phase1Step === 'normalization' }">
              <p class="font-semibold text-lg">3. è³‡æ–™æ­£è¦åŒ–</p>
              <p class="text-xs text-gray-400 mt-1">å°‡ä¸åŒå°ºåº¦çš„ç‰¹å¾µï¼ˆä¾‹å¦‚é‡‘é¡èˆ‡æ¬¡æ•¸ï¼‰ç¸®æ”¾åˆ°çµ±ä¸€ç¯„åœã€‚</p>
            </div>
          </div>
        </div>
      </section>

      <!-- éšæ®µäºŒï¼šç†è§£ - æ¨¡å‹çš„å­¸ç¿’éç¨‹ -->
      <section class="phase-container" :class="{ 'active': currentPhase === 2 }">
        <div class="text-center mb-4">
          <h2 class="text-3xl font-semibold mb-2">éšæ®µäºŒï¼šç†è§£</h2>
          <p class="text-gray-400 text-sm">æ¨¡å‹å¦‚ä½•å¾é¡§å®¢è¡Œç‚ºä¸­æ‰¾åˆ°è³¼è²·è¦å¾‹ã€‚</p>
        </div>
        <div class="visualizer">
          <div class="flex justify-center items-center mb-4 space-x-4 flex-wrap">
            <span class="text-gray-400 text-sm">æ¨¡å‹é¡å‹:</span>
            <button @click="modelType = 'classification'" :class="{'bg-gray-600': modelType === 'classification'}" class="px-4 py-2 rounded-full border border-gray-500 text-sm transition-colors" :disabled="isTraining">åˆ†é¡</button>
            <button @click="modelType = 'regression'" :class="{'bg-gray-600': modelType === 'regression'}" class="px-4 py-2 rounded-full border border-gray-500 text-sm transition-colors" :disabled="isTraining">è¿´æ­¸</button>
            <span class="text-gray-400 text-sm ml-4" v-if="modelType === 'classification'">æ±ºç­–é‚Šç•Œ:</span>
            <button v-if="modelType === 'classification'" @click="isComplexModel = false" :class="{'bg-gray-600': !isComplexModel}" class="px-4 py-2 rounded-full border border-gray-500 text-sm transition-colors" :disabled="isTraining">ç·šæ€§</button>
            <button v-if="modelType === 'classification'" @click="isComplexModel = true" :class="{'bg-gray-600': isComplexModel}" class="px-4 py-2 rounded-full border border-gray-500 text-sm transition-colors" :disabled="isTraining">éç·šæ€§</button>
          </div>
          <div @click="handlePredictionClick" class="training-area relative h-96 w-full">
            <div v-if="modelTrained && modelType === 'classification'">
                <p class="text-center text-gray-400 text-sm mb-2">è¨“ç·´è³‡æ–™ï¼ˆæœ‰è‰²é»ï¼‰ï¼Œèˆ‡é©—è­‰è³‡æ–™ï¼ˆç¶ æ¡†é»ï¼‰</p>
            </div>
            <div v-if="modelType === 'classification'" class="w-full h-full relative border border-dashed border-gray-600 rounded-xl">
              <div v-for="(point, index) in trainingData" :key="'train-' + index" 
                   @mouseenter="showTooltip($event, point)" 
                   @mouseleave="hideTooltip"
                   class="data-point" 
                   :class="`bg-${point.type}-500 ${point.isMisclassified ? 'misclassified-point' : ''}`" 
                   :style="{ left: `${point.x}%`, top: `${100 - point.y}%` }"></div>
              <div v-for="(point, index) in validationData" :key="'val-' + index" 
                   @mouseenter="showTooltip($event, point)" 
                   @mouseleave="hideTooltip"
                   class="data-point" 
                   :class="`bg-${point.type}-500 opacity-60 ${point.isMisclassified ? 'misclassified-point' : ''}`" 
                   :style="{ left: `${point.x}%`, top: `${100 - point.y}%`, border: '2px solid #22c55e' }"></div>
              
              <div v-if="isTraining || modelTrained" class="decision-boundary" :style="{ transform: `rotate(${decisionBoundaryRotation}deg)` }"></div>
              <div v-if="isComplexModel && (isTraining || modelTrained)" class="absolute inset-0">
                  <div class="decision-boundary decision-boundary-complex left-1/4" :style="{ transform: `rotate(${decisionBoundaryRotation * 0.5}deg)`}"></div>
                  <div class="decision-boundary decision-boundary-complex left-3/4" :style="{ transform: `rotate(${decisionBoundaryRotation * 1.5}deg)`}"></div>
              </div>

              <div v-if="newPoint" class="new-data-point" :style="{ left: `${newPoint.x}%`, top: `${100 - newPoint.y}%` }"></div>

            </div>
            <div v-if="modelType === 'regression'" class="w-full h-full relative border border-dashed border-gray-600 rounded-xl">
              <div v-for="(point, index) in trainingData" :key="'train-' + index" class="data-point bg-yellow-500" :style="{ left: `${point.x}%`, top: `${100 - point.y}%` }"></div>
              <div v-if="isTraining || modelTrained" class="regression-line"></div>
            </div>
          </div>

          <!-- è³‡æ–™é»è³‡è¨Šæ°£æ³¡ -->
          <div v-if="hoveredPoint" class="tooltip" :style="{ left: `${tooltip.x}px`, top: `${tooltip.y}px` }" :class="{'visible': tooltip.visible}">
            <p>ç€è¦½æ¬¡æ•¸ï¼š{{ Math.round(hoveredPoint.x) }}</p>
            <p>è³¼ç‰©é‡‘é¡ï¼š${{ Math.round(hoveredPoint.y * 10) }}</p>
          </div>

          <div class="training-info mt-4 w-full">
            <p v-if="isTraining" class="text-center text-sm">
                æ¨¡å‹è¨“ç·´ä¸­... <span class="text-blue-400">è¨“ç·´é€±æœŸ (Epoch): {{ currentEpoch }}</span>
            </p>
            <p v-else-if="modelTrained" class="text-center text-sm text-green-400 font-bold">
                æ¨¡å‹è¨“ç·´å®Œæˆï¼
            </p>
            <div class="flex justify-center items-center space-x-4 mt-2">
                <p class="text-green-300">
                    <span class="font-semibold text-xs">è¨“ç·´æº–ç¢ºç‡:</span> <span class="text-lg font-bold" :class="{'value-change-animation': !isTraining}">{{ trainingAccuracy.toFixed(2) }}%</span>
                </p>
                <p class="text-yellow-300">
                    <span class="font-semibold text-xs">é©—è­‰æº–ç¢ºç‡:</span> <span class="text-lg font-bold" :class="{'value-change-animation': !isTraining}">{{ validationAccuracy.toFixed(2) }}%</span>
                </p>
            </div>
            <div class="loss-graph">
              <canvas id="lossCanvas" class="w-full h-full"></canvas>
            </div>
          </div>
        </div>
      </section>

      <!-- éšæ®µä¸‰ï¼šè¡Œå‹• - é æ¸¬èˆ‡æ±ºç­– -->
      <section class="phase-container" :class="{ 'active': currentPhase === 3 }">
        <div class="text-center mb-4">
          <h2 class="text-3xl font-semibold mb-2">éšæ®µä¸‰ï¼šè¡Œå‹•</h2>
          <p class="text-gray-400 text-sm">å°‡è¨“ç·´å¥½çš„æ¨¡å‹æ‡‰ç”¨æ–¼æ–°çš„é¡§å®¢è³‡æ–™ã€‚</p>
        </div>
        <div class="visualizer">
          <div v-if="!predictionResult && !isAutomating && !showEndingStep" class="w-full text-center p-8 border border-dashed border-gray-600 rounded-xl bg-gray-700/50 animate-pulse">
              <p class="text-lg text-blue-300 font-bold mb-2">è«‹é»æ“Šå·¦å´åœ–è¡¨ï¼ŒåŠ å…¥æ–°çš„é¡§å®¢æ•¸æ“š</p>
              <div class="flex justify-center items-center text-4xl mt-4">
                  <span class="animate-bounce">ğŸ‘‰</span>
              </div>
          </div>
          <div v-else-if="isAutomating" class="w-full text-center p-8">
              <p class="text-lg text-gray-400 font-bold mb-2 animate-pulse">æ–°é¡§å®¢æ•¸æ“šæ­£åœ¨é€šéæ¨¡å‹...</p>
          </div>
          
          <div v-if="predictionResult" class="w-full prediction-container">
              <div class="flex items-center space-x-4 mb-4">
                  <span class="text-5xl" v-if="predictionResult.isHighValue">ğŸ’°</span>
                  <span class="text-5xl" v-else>ğŸ§‘â€ğŸ¤â€ğŸ§‘</span>
              </div>
              <div class="p-4 rounded-xl border border-gray-600 bg-gray-700/50 w-full text-center final-prediction-result" :class="{'active': predictionResult}">
                  <p class="text-xl font-bold mb-2">é æ¸¬çµæœï¼š{{ predictionResult.label }}</p>
                  <p class="text-sm text-gray-300">
                      æ ¹æ“šæ¨¡å‹é æ¸¬ï¼Œé€™ä½é¡§å®¢çš„æœ€çµ‚è¡ŒéŠ·æ±ºç­–ç‚ºï¼š<span class="font-bold text-lg" :class="`text-${predictionResult.color}-300`">{{ predictionResult.decision }}</span>
                  </p>
              </div>
              <div class="mt-8">
                <p class="text-center text-lg font-bold">é€™æ˜¯æ­£ç¢ºçš„é æ¸¬å—ï¼Ÿ</p>
                <div class="flex justify-center space-x-4 mt-2">
                  <button @click="provideFeedback(true)" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded-full">æ˜¯</button>
                  <button @click="provideFeedback(false)" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-full">å¦ (å›é¥‹éŒ¯èª¤)</button>
                </div>
              </div>
          </div>

          <div v-if="showEndingStep" class="ending-step-container active w-full text-center p-8 border border-dashed border-gray-600 rounded-xl bg-gray-700/50 mt-8">
            <h3 class="text-xl font-bold text-green-300 mb-4">æœ¬è¼ªåˆ†æçµæŸ</h3>
            <p class="text-gray-400 mb-4">ä½ å·²æˆåŠŸå®Œæˆæœ¬è¼ªçš„ AI åˆ†ææµç¨‹ã€‚ç¾åœ¨ä½ å¯ä»¥é¸æ“‡ï¼š</p>
            <div class="flex justify-center space-x-4">
                <button @click="resetStates" class="px-6 py-2 bg-blue-600 hover:bg-blue-700 rounded-full font-bold">é–‹å§‹æ–°çš„åˆ†æ</button>
                <button @click="showDeepDive = true" class="px-6 py-2 bg-gray-600 hover:bg-gray-700 rounded-full font-bold">æ·±å…¥äº†è§£æ¦‚å¿µ</button>
            </div>
          </div>
        </div>
      </section>
    </div>

    <!-- æµç¨‹ç¸½çµèˆ‡ç›®æ¨™å€å¡Š -->
    <section v-if="!isAutomating && currentPhase === 3" class="summary-section active w-full max-w-4xl mt-12 bg-gray-800 p-8 rounded-xl shadow-2xl">
      <h2 class="text-3xl font-bold text-center mb-6">æƒ…å¢ƒç¸½çµèˆ‡ç›®æ¨™çµæœ</h2>
      <div class="space-y-6 text-gray-300">
        <div>
          <h3 class="text-2xl font-semibold text-blue-400 mb-2">æƒ…å¢ƒç¸½çµ (Scenario Summary)</h3>
          <p class="text-lg leading-relaxed">
            æˆ‘å€‘çš„ç›®æ¨™æ˜¯åˆ©ç”¨æ­·å²æ•¸æ“šï¼Œä¾†é æ¸¬æ–°åŠ å…¥çš„é›»å­å•†å‹™é¡§å®¢æ˜¯å±¬æ–¼**ã€Œé«˜åƒ¹å€¼é¡§å®¢ã€**é‚„æ˜¯**ã€Œæ™®é€šé¡§å®¢ã€**ã€‚é«˜åƒ¹å€¼é¡§å®¢çš„ç‰¹å¾µæ˜¯**ç€è¦½æ¬¡æ•¸å¤šä¸”å–®æ¬¡æ¶ˆè²»é‡‘é¡é«˜**ã€‚æ¨¡å‹å°‡å­¸ç¿’å¦‚ä½•å¾é€™äº›ç‰¹å¾µä¸­å€åˆ†å…©é¡é¡§å®¢ã€‚
          </p>
        </div>
        
        <div>
          <h3 class="text-2xl font-semibold text-green-400 mb-2">æµç¨‹è§£æ (Process Breakdown)</h3>
          <ul class="list-disc list-inside space-y-2 text-lg">
            <li>**éšæ®µä¸€ï¼šæ„ŸçŸ¥** - æˆ‘å€‘å°‡åŸå§‹çš„é¡§å®¢æ•¸æ“šï¼ˆå¦‚ç€è¦½ç´€éŒ„ã€è³¼ç‰©è»Šå…§å®¹ç­‰ï¼‰é€²è¡Œ**æ¸…æ´—**ã€**ç‰¹å¾µåŒ–**ï¼Œä¸¦**æ­£è¦åŒ–**ç‚º AI å¯ç†è§£çš„æ ¼å¼ï¼ˆä¾‹å¦‚ï¼šå°‡ã€Œæœ€è¿‘ç€è¦½æ¬¡æ•¸ã€èˆ‡ã€Œå–®æ¬¡è³¼ç‰©é‡‘é¡ã€è½‰åŒ–ç‚ºäºŒç¶­åº§æ¨™ï¼‰ã€‚</li>
            <li>**éšæ®µäºŒï¼šç†è§£** - æ¨¡å‹ä½¿ç”¨é€™äº›è™•ç†éçš„æ•¸æ“šé€²è¡Œ**è¨“ç·´**ã€‚åœ¨æ¯å€‹**è¨“ç·´é€±æœŸ (Epoch)** ä¸­ï¼Œæ¨¡å‹æœƒåè¦†èª¿æ•´å…§éƒ¨åƒæ•¸ï¼Œä»¥æœ€å°åŒ–**æå¤±å‡½æ•¸ (Loss Function)**ã€‚æ‚¨å¯ä»¥çœ‹åˆ°æ¨¡å‹çš„ã€Œæ±ºç­–é‚Šç•Œã€æˆ–ã€Œè¿´æ­¸ç·šã€ä¸æ–·å„ªåŒ–ï¼Œç›´åˆ°èƒ½å¤ æº–ç¢ºå€åˆ†å…©é¡é¡§å®¢ã€‚</li>
            <li>**éšæ®µä¸‰ï¼šè¡Œå‹•** - è¨“ç·´å®Œæˆå¾Œï¼Œæ¨¡å‹å·²ç¶“å…·å‚™é æ¸¬èƒ½åŠ›ã€‚ç•¶æœ‰æ–°çš„é¡§å®¢æ•¸æ“šé€²ä¾†æ™‚ï¼Œæ¨¡å‹æœƒæ ¹æ“šå­¸åˆ°çš„è¦å¾‹ï¼Œå¿«é€Ÿåšå‡º**é æ¸¬**ï¼Œä¸¦æä¾›**æœ€çµ‚çš„å•†æ¥­æ±ºç­–**ã€‚</li>
            <li>**å›é¥‹è¿´åœˆ** - æœ€é‡è¦çš„æ˜¯ï¼Œæˆ‘å€‘å°‡é æ¸¬çµæœèˆ‡å¯¦éš›å•†æ¥­çµæœé€²è¡Œæ¯”å°ã€‚å¦‚æœç™¼ç¾æ¨¡å‹é æ¸¬éŒ¯èª¤ï¼Œæˆ‘å€‘å°‡é€™å€‹éŒ¯èª¤çš„æ•¸æ“šé»å›é¥‹çµ¦æ¨¡å‹ï¼Œé€²è¡Œ**å†è¨“ç·´**ï¼Œè®“æ¨¡å‹åœ¨æœªä¾†åšå¾—æ›´å¥½ã€‚</li>
          </ul>
        </div>
        
        <div>
          <h3 class="text-2xl font-semibold text-yellow-400 mb-2">ç›®æ¨™çµæœ (Target Outcome)</h3>
          <p class="text-lg leading-relaxed">
            é€éé€™æ•´å€‹æµç¨‹ï¼Œæˆ‘å€‘èƒ½å¤ å°‡æ–°é¡§å®¢è‡ªå‹•åˆ†çµ„ã€‚å°æ–¼è¢«é æ¸¬ç‚º**ã€Œé«˜åƒ¹å€¼é¡§å®¢ã€**çš„ç¾¤é«”ï¼Œæˆ‘å€‘å¯ä»¥ç«‹å³ç™¼é€**ç¨å®¶æŠ˜æ‰£ä»£ç¢¼**ï¼Œä»¥æ­¤æé«˜è½‰æ›ç‡å’Œé¡§å®¢å¿ èª åº¦ã€‚å°æ–¼**ã€Œæ™®é€šé¡§å®¢ã€**ï¼Œå‰‡å¯ä»¥ç™¼é€**ä¸€èˆ¬ä¿ƒéŠ·è¨Šæ¯**ï¼Œé€²è¡Œæœ‰æ•ˆçš„å·®ç•°åŒ–è¡ŒéŠ·ï¼Œå¾è€Œå¯¦ç¾å•†æ¥­åƒ¹å€¼çš„æœ€å¤§åŒ–ã€‚
          </p>
        </div>
      </div>
    </section>

    <!-- æ–°å¢çš„æ•™å­¸å€å¡Š -->
    <section v-if="showDeepDive" class="deep-dive-section active w-full max-w-4xl mt-12 bg-gray-800 p-8 rounded-xl shadow-2xl">
      <h2 class="text-3xl font-bold text-center mb-6">æ·±å…¥æ¢è¨ AI æ ¸å¿ƒæ¦‚å¿µ</h2>
      <div class="space-y-8 text-gray-300">
        <div>
          <h3 class="text-2xl font-semibold text-purple-400 mb-2">æå¤±å‡½æ•¸ (Loss Function) æ˜¯ä»€éº¼ï¼Ÿ</h3>
          <p class="text-lg leading-relaxed">
            åœ¨ AI å­¸ç¿’çš„éç¨‹ä¸­ï¼Œ**æå¤±å‡½æ•¸**å°±åƒæ˜¯æ¨¡å‹çš„ã€Œæ•™ç·´ã€ã€‚å®ƒçš„ä½œç”¨æ˜¯è¡¡é‡æ¨¡å‹é æ¸¬çµæœèˆ‡å¯¦éš›æ­£ç¢ºç­”æ¡ˆä¹‹é–“çš„å·®ç•°æœ‰å¤šå¤§ã€‚å¦‚æœæ¨¡å‹çš„é æ¸¬è¶Šæ¥è¿‘çœŸå¯¦ç­”æ¡ˆï¼Œæå¤±å€¼å°±è¶Šä½ã€‚
            <br/><br/>
            ä¾‹å¦‚ï¼Œåœ¨æˆ‘å€‘çš„é¡§å®¢åˆ†é¡æƒ…å¢ƒä¸­ï¼Œå¦‚æœæ¨¡å‹é æ¸¬æŸä½é¡§å®¢æ˜¯ã€Œæ™®é€šé¡§å®¢ã€ï¼Œä½†å¯¦éš›ä¸Šä»–æ˜¯ä¸€ä½ã€Œé«˜åƒ¹å€¼é¡§å®¢ã€ï¼Œé‚£éº¼æå¤±å‡½æ•¸å°±æœƒè¨ˆç®—å‡ºä¸€å€‹è¼ƒé«˜çš„æå¤±å€¼ï¼Œå‘Šè¨´æ¨¡å‹ï¼šã€Œä½ éŒ¯äº†ï¼Œè¦èª¿æ•´ï¼ã€
          </p>
        </div>
        
        <div>
          <h3 class="text-2xl font-semibold text-teal-400 mb-2">æ±ºç­–é‚Šç•Œ (Decision Boundary) å¦‚ä½•å½¢æˆï¼Ÿ</h3>
          <p class="text-lg leading-relaxed">
            **æ±ºç­–é‚Šç•Œ**æ˜¯åˆ†é¡æ¨¡å‹å­¸ç¿’çš„æœ€çµ‚æˆæœã€‚å®ƒæ˜¯ä¸€æ¢å°‡ä¸åŒé¡åˆ¥è³‡æ–™é»åˆ†é–‹çš„è™›æ“¬ç·šæˆ–æ›²é¢ã€‚åœ¨æˆ‘å€‘çš„è¦–è¦ºåŒ–ä¸­ï¼Œæ‚¨å¯ä»¥è§€å¯Ÿåˆ°é€™æ¢ç·šåœ¨è¨“ç·´éç¨‹ä¸­ä¸æ–·èª¿æ•´ï¼Œç›®çš„æ˜¯æ‰¾åˆ°ä¸€å€‹æœ€ä½³ä½ç½®ï¼Œèƒ½å¤ æœ€æœ‰æ•ˆåœ°å°‡ã€Œé«˜åƒ¹å€¼é¡§å®¢ã€ï¼ˆç´…é»ï¼‰å’Œã€Œæ™®é€šé¡§å®¢ã€ï¼ˆè—é»ï¼‰å€åˆ†é–‹ä¾†ã€‚
            <br/><br/>
            å¦‚æœæˆ‘å€‘é¸æ“‡ä¸€å€‹**ç·šæ€§**æ¨¡å‹ï¼Œæ±ºç­–é‚Šç•Œå°±æ˜¯ä¸€æ¢ç›´ç·šã€‚è€Œå°æ–¼æ›´è¤‡é›œçš„**éç·šæ€§**æ¨¡å‹ï¼Œæ±ºç­–é‚Šç•Œå¯ä»¥æ˜¯å¤šæ¢ç·šæˆ–æ›²ç·šï¼Œèƒ½å¤ è™•ç†æ›´é›£ä»¥å€åˆ†çš„æ•¸æ“šé›†ã€‚
          </p>
        </div>

        <div class="text-center">
            <button @click="showDeepDive = false; showEndingStep = true" class="px-8 py-3 bg-red-600 hover:bg-red-700 rounded-full font-bold transition-colors">è¿”å›</button>
        </div>
      </div>
    </section>
  </div>

  <script type="module">
    const { createApp, ref, reactive, computed, onMounted } = Vue;

    const app = createApp({
      setup() {
        const currentPhase = ref(1);
        const phase1Step = ref('raw'); 
        const modelType = ref('classification');
        const isComplexModel = ref(false); 
        const isTraining = ref(false);
        const modelTrained = ref(false);
        const trainingAccuracy = ref(0);
        const validationAccuracy = ref(0);
        const currentEpoch = ref(0);
        const decisionBoundaryRotation = ref(0);
        const trainingData = ref([]);
        const validationData = ref([]);
        const predictionResult = ref(null);
        const isAutomating = ref(false);
        const lossHistory = ref([]);
        const newPoint = ref(null); 
        const showEndingStep = ref(false); // æ§åˆ¶çµæŸæ­¥é©Ÿçš„é¡¯ç¤º
        const showDeepDive = ref(false); // æ§åˆ¶æ·±å…¥æ•™å­¸å€å¡Šçš„é¡¯ç¤º

        // è³‡æ–™é»æ°£æ³¡
        const hoveredPoint = ref(null);
        const tooltip = reactive({ x: 0, y: 0, visible: false });

        const icons = ['ğŸ“„', 'ğŸ–¼ï¸', 'ğŸ“Š', 'ğŸ”Š', 'ğŸ“', 'ğŸ›’', 'ğŸ“¦', 'ğŸ“ˆ', 'ğŸ’¬', 'ğŸ“', 'ğŸ’°', 'ğŸ§‘â€ğŸ¤â€ğŸ§‘', 'ğŸŒ', 'ğŸ“'];
        
        // é å…ˆå®šç¾©çš„æ¨¡æ“¬è³‡æ–™é›†
        const simulatedData = [
            // é«˜åƒ¹å€¼é¡§å®¢ (High-Value Customers) - é è¿‘å³ä¸Šæ–¹
            { x: 75, y: 85, type: 'red' }, { x: 80, y: 90, type: 'red' }, { x: 90, y: 75, type: 'red' },
            { x: 85, y: 80, type: 'red' }, { x: 70, y: 95, type: 'red' }, { x: 88, y: 88, type: 'red' },
            { x: 95, y: 70, type: 'red' }, { x: 72, y: 82, type: 'red' }, { x: 81, y: 89, type: 'red' },
            { x: 78, y: 92, type: 'red' }, { x: 65, y: 88, type: 'red' }, { x: 92, y: 68, type: 'red' },
            
            // æ™®é€šé¡§å®¢ (Regular Customers) - é è¿‘å·¦ä¸‹æ–¹
            { x: 20, y: 30, type: 'blue' }, { x: 30, y: 25, type: 'blue' }, { x: 15, y: 40, type: 'blue' },
            { x: 40, y: 15, type: 'blue' }, { x: 25, y: 35, type: 'blue' }, { x: 35, y: 20, type: 'blue' },
            { x: 18, y: 38, type: 'blue' }, { x: 28, y: 28, type: 'blue' }, { x: 45, y: 10, type: 'blue' },
            { x: 33, y: 42, type: 'blue' }, { x: 12, y: 33, type: 'blue' }, { x: 22, y: 22, type: 'blue' },

            // éš¨æ©Ÿè³‡æ–™é»
            { x: 50, y: 60, type: 'red' }, { x: 60, y: 45, type: 'blue' }, { x: 40, y: 55, type: 'blue' },
            { x: 55, y: 50, type: 'blue' }, { x: 62, y: 58, type: 'red' }, { x: 48, y: 42, type: 'blue' },
            { x: 70, y: 50, type: 'red' }, { x: 30, y: 65, type: 'red' }, { x: 65, y: 30, type: 'blue' },
            { x: 50, y: 80, type: 'red' }, { x: 40, y: 20, type: 'blue' }, { x: 60, y: 70, type: 'red' },
            { x: 35, y: 60, type: 'red' }, { x: 75, y: 25, type: 'blue' }, { x: 80, y: 50, type: 'red' },
            { x: 25, y: 70, type: 'red' }, { x: 70, y: 40, type: 'blue' }, { x: 45, y: 85, type: 'red' },
            { x: 85, y: 35, type: 'blue' }, { x: 30, y: 50, type: 'blue' }, { x: 55, y: 75, type: 'red' },
        ];


        const nextButtonText = computed(() => {
          if (currentPhase.value === 1) {
            if (phase1Step.value === 'raw') return 'ä¸‹ä¸€æ­¥ï¼šè³‡æ–™æ¸…æ´—';
            if (phase1Step.value === 'cleaning') return 'ä¸‹ä¸€æ­¥ï¼šç‰¹å¾µå·¥ç¨‹';
            if (phase1Step.value === 'features') return 'ä¸‹ä¸€æ­¥ï¼šè³‡æ–™æ­£è¦åŒ–';
            if (phase1Step.value === 'normalization') return 'é€²å…¥éšæ®µäºŒï¼šç†è§£';
          }
          if (currentPhase.value === 2) {
            if (!modelTrained.value) return 'é–‹å§‹è¨“ç·´æ¨¡å‹';
            return 'é€²å…¥éšæ®µä¸‰ï¼šè¡Œå‹•';
          }
          if (currentPhase.value === 3) return 'é‡ç½®æµç¨‹';
          return 'é–‹å§‹';
        });

        const getIconStyle = (index) => {
          const x = Math.random() * 90 + 5;
          const y = Math.random() * 90 + 5;
          return {
            top: `${y}%`,
            left: `${x}%`,
            animationDelay: `${Math.random() * 2}s`,
            transform: `rotate(${Math.random() * 360}deg)`,
          };
        };
        const getIcon = (index) => {
          return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Ctext x='50%25' y='50%25' dominant-baseline='central' text-anchor='middle' font-size='20' fill='%23fff'%3E${icons[index % icons.length]}%3C/text%3E%3C/svg%3E`;
        };

        const nextPhase = () => {
            if (isAutomating.value) return;

            if (currentPhase.value === 1) {
                if (phase1Step.value === 'raw') {
                    phase1Step.value = 'cleaning';
                    document.querySelectorAll('.data-icon').forEach(icon => {
                        if (Math.random() > 0.8) icon.classList.add('fade-out');
                    });
                } else if (phase1Step.value === 'cleaning') {
                    phase1Step.value = 'features';
                } else if (phase1Step.value === 'features') {
                    phase1Step.value = 'normalization';
                } else if (phase1Step.value === 'normalization') {
                    currentPhase.value = 2;
                    generateDataPoints();
                }
            } else if (currentPhase.value === 2) {
                if (!modelTrained.value) {
                    startTraining();
                } else {
                    currentPhase.value = 3;
                }
            } else if (currentPhase.value === 3) {
                resetStates();
            }
        };

        const startAutomation = () => {
            if (isAutomating.value) return;
            isAutomating.value = true;
            resetStates();
            
            // è¦–è¦ºå¼•å°å‹•ç•«
            const pipelineSteps = document.querySelectorAll('.pipeline-step, .pipeline-arrow');
            let stepIndex = 0;
            const animateStep = () => {
                if (stepIndex < pipelineSteps.length) {
                    pipelineSteps[stepIndex].classList.add('active');
                    stepIndex++;
                    setTimeout(animateStep, 1000);
                }
            };
            
            setTimeout(() => {
                phase1Step.value = 'cleaning';
                const icons = document.querySelectorAll('.data-icon');
                icons.forEach(icon => { if (Math.random() > 0.8) icon.classList.add('fade-out'); });
                animateStep();
                setTimeout(() => {
                    phase1Step.value = 'features';
                    setTimeout(() => {
                        phase1Step.value = 'normalization';
                        setTimeout(() => {
                            currentPhase.value = 2;
                            generateDataPoints();
                            startTraining(true);
                        }, 2000);
                    }, 2000);
                }, 2000);
            }, 500);
        };
        
        const resetStates = () => {
            currentPhase.value = 1;
            phase1Step.value = 'raw';
            isTraining.value = false;
            modelTrained.value = false;
            trainingAccuracy.value = 0;
            validationAccuracy.value = 0;
            currentEpoch.value = 0;
            predictionResult.value = null;
            newPoint.value = null;
            lossHistory.value = [];
            isAutomating.value = false;
            showEndingStep.value = false;
            showDeepDive.value = false;
            document.querySelectorAll('.data-icon').forEach(icon => icon.classList.remove('fade-out'));
            
            // é‡ç½®æ‰€æœ‰è³‡æ–™é»çš„ misclassified ç‹€æ…‹
            trainingData.value.forEach(p => p.isMisclassified = false);
            validationData.value.forEach(p => p.isMisclassified = false);
        };

        const generateDataPoints = () => {
          trainingData.value = [];
          validationData.value = [];
          simulatedData.forEach(point => {
            const isValidation = Math.random() > 0.8; 
            if (isValidation) {
                validationData.value.push({...point, isMisclassified: false});
            } else {
                trainingData.value.push({...point, isMisclassified: false});
            }
          });
        };

        const startTraining = (isAuto = false) => {
          isTraining.value = true;
          lossHistory.value = [];
          
          let currentTrainingAccuracy = 0;
          let currentValidationAccuracy = 0;

          const trainingInterval = setInterval(() => {
            currentTrainingAccuracy += Math.random() * 4 + 2;
            currentValidationAccuracy = currentTrainingAccuracy * (0.95 + Math.random() * 0.05);
            currentEpoch.value++;

            const loss = 100 - currentTrainingAccuracy;
            lossHistory.value.push(loss);
            drawLossGraph();

            if (currentTrainingAccuracy > 95 || currentEpoch.value >= 20) {
              currentTrainingAccuracy = 98.5;
              currentValidationAccuracy = 95.2 + Math.random() * 3;
              clearInterval(trainingInterval);
              isTraining.value = false;
              modelTrained.value = true;
              trainingAccuracy.value = currentTrainingAccuracy;
              validationAccuracy.value = currentValidationAccuracy;

              if (isAuto) {
                setTimeout(() => {
                  currentPhase.value = 3;
                }, 2000);
              }
            }
            trainingAccuracy.value = currentTrainingAccuracy;
            validationAccuracy.value = currentValidationAccuracy;

            if (modelType.value === 'classification') {
              if (isComplexModel.value) {
                decisionBoundaryRotation.value = 45 + (Math.random() - 0.5) * 40;
              } else {
                decisionBoundaryRotation.value = 45 + (Math.random() - 0.5) * 20 - (currentTrainingAccuracy/100) * 10;
              }
            }
          }, 150);
        };
        
        const drawLossGraph = () => {
            const canvas = document.getElementById('lossCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const maxLoss = 100;
            const data = lossHistory.value;
            if (data.length < 2) return;

            const xStep = canvas.width / dpr / (data.length - 1);

            ctx.beginPath();
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;

            ctx.moveTo(0, canvas.height / dpr - (data[0] / maxLoss) * canvas.height / dpr);
            for (let i = 1; i < data.length; i++) {
                ctx.lineTo(i * xStep, canvas.height / dpr - (data[i] / maxLoss) * canvas.height / dpr);
            }
            ctx.stroke();

            // Draw current loss
            const lastLoss = data[data.length - 1];
            ctx.fillStyle = '#f87171';
            ctx.beginPath();
            ctx.arc((data.length - 1) * xStep, canvas.height / dpr - (lastLoss / maxLoss) * canvas.height / dpr, 4, 0, 2 * Math.PI);
            ctx.fill();

            // Display text
            ctx.fillStyle = '#f87171';
            ctx.font = `bold 16px Inter`;
            ctx.textAlign = 'center';
            ctx.fillText(`æå¤±å€¼: ${lastLoss.toFixed(2)}%`, canvas.width / dpr / 2, 20);
        };


        const handlePredictionClick = (event) => {
            if (currentPhase.value !== 3 || isAutomating.value) return;

            const rect = event.currentTarget.getBoundingClientRect();
            const x = (event.clientX - rect.left) / rect.width * 100;
            const y = (rect.height - (event.clientY - rect.top)) / rect.height * 100;

            predict({ x, y });
        };
        
        const predict = (point) => {
            const newPointData = point;
            newPoint.value = newPointData;
            
            const isHighValue = newPointData.y > newPointData.x + 10;
            let result = '';
            let color = '';
            let decision = '';
            
            if (modelType.value === 'classification') {
                if (isHighValue) {
                    result = 'é«˜åƒ¹å€¼é¡§å®¢';
                    color = 'red';
                    decision = 'ç™¼é€ç¨å®¶æŠ˜æ‰£ä»£ç¢¼';
                } else {
                    result = 'æ™®é€šé¡§å®¢';
                    color = 'blue';
                    decision = 'ç™¼é€ä¸€èˆ¬ä¿ƒéŠ·è¨Šæ¯';
                }
            } else {
                const predictedValue = (newPointData.x + newPointData.y) / 2;
                result = `é æ¸¬æ¶ˆè²»é¡: $${predictedValue.toFixed(2)}`;
                color = 'yellow';
                decision = `å»ºè­°è¡ŒéŠ·é ç®—ç‚º $${predictedValue.toFixed(2)}`;
            }
            
            predictionResult.value = { 
                label: result, 
                color, 
                decision, 
                isHighValue, 
                trueLabel: isHighValue ? 'red' : 'blue',
                x: newPointData.x,
                y: newPointData.y
            };
        };

        const provideFeedback = (isCorrect) => {
            if (!isCorrect) {
                const pointToUpdate = predictionResult.value;
                pointToUpdate.isMisclassified = true;
                
                trainingData.value.push({
                    x: pointToUpdate.x,
                    y: pointToUpdate.y,
                    type: pointToUpdate.trueLabel, 
                    isMisclassified: true
                });
                
                predictionResult.value = null;
                newPoint.value = null;
                modelTrained.value = false;
                currentEpoch.value = 0;
                startTraining();
            } else {
              predictionResult.value = null;
              newPoint.value = null;
              showEndingStep.value = true;
            }
        };

        const showTooltip = (event, point) => {
            hoveredPoint.value = point;
            tooltip.x = event.clientX;
            tooltip.y = event.clientY;
            tooltip.visible = true;
        };

        const hideTooltip = () => {
            hoveredPoint.value = null;
            tooltip.visible = false;
        };

        onMounted(() => {
          generateDataPoints();
        });

        return {
          currentPhase,
          phase1Step,
          modelType,
          isComplexModel,
          isTraining,
          modelTrained,
          trainingAccuracy,
          validationAccuracy,
          currentEpoch,
          decisionBoundaryRotation,
          trainingData,
          validationData,
          predictionResult,
          isAutomating,
          icons,
          nextButtonText,
          newPoint,
          hoveredPoint,
          tooltip,
          showEndingStep,
          showDeepDive,
          getIconStyle,
          getIcon,
          nextPhase,
          startAutomation,
          startTraining,
          handlePredictionClick,
          provideFeedback,
          showTooltip,
          hideTooltip,
          resetStates
        };
      }
    });

    app.mount('#ai-app');
  </script>
</body>
</html>
